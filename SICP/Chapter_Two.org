# -*- mode: org; coding: utf-8 -*-
#+TITLE: SICP Chapter Two
#+STARTUP: overview

* 2.1
** 2.1
*Exercise 2.1:* Define a better version of `make-rat' that handles
both positive and negative arguments.  `Make-rat' should normalize
the sign so that if the rational number is positive, both the
numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.

#+begin_src scheme :results raw
(define (make-rat n d)
  (let* ((positive (or (and (<= n 0) (<= d 0))
                       (and (>= n 0) (>= d 0))))
         (g (gcd n d))
         (a (/ (if positive (abs n) (- (abs n))) g))
         (b (/ (abs d) g)))
    (cons a b)))

(make-rat -2 -4)
#+end_src
** 2.2
*Exercise 2.2:* Consider the problem of representing line segments
in a plane.  Each segment is represented as a pair of points: a
starting point and an ending point.  Define a constructor
`make-segment' and selectors `start-segment' and `end-segment'
that define the representation of segments in terms of points.
Furthermore, a point can be represented as a pair of numbers: the
x coordinate and the y coordinate.  Accordingly, specify a
constructor `make-point' and selectors `x-point' and `y-point'
that define this representation.  Finally, using your selectors
and constructors, define a procedure `midpoint-segment' that takes
a line segment as argument and returns its midpoint (the point
whose coordinates are the average of the coordinates of the
endpoints).  To try your procedures, you'll need a way to print
points:

(define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
   
#+begin_src scheme :results output
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

(define (make-segment beg end)
  (cons beg end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))

(define (mid-point-segment seg)
  (let* ((beg (start-segment seg))
         (end (end-segment seg))
         (beg_x (x-point beg))
         (beg_y (y-point beg))
         (end_x (x-point end))
         (end_y (y-point end)))
    (make-point (/ (+ beg_x end_x) 2)
                (/ (+ beg_y end_y) 2))
    )
  )

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(print-point (make-point 1 2))
#+end_src
** 2.3
*Exercise 2.3:* Implement a representation for rectangles in a
plane.  (Hint: You may want to make use of *Note Exercise 2-2::.)
In terms of your constructors and selectors, create procedures
that compute the perimeter and the area of a given rectangle.  Now
implement a different representation for rectangles.  Can you
design your system with suitable abstraction barriers, so that the
same perimeter and area procedures will work using either
representation?
#+begin_src scheme
(define (make-rectangle x y)
  (if (>= x y)
      (cons x y)
      (cons y x)))

(define (get-long r)
  (car x))

(define (get-short r)
  (cdr y))

(define (rec-area r)
  (* (get-long r)
     (get-short r)))

(define (rec-perimeter r)
  (+ (* 2 (get-long r))
     (* 2 (get-short r))))
#+end_src
** 2.4
*Exercise 2.4:* Here is an alternative procedural representation
of pairs.  For this representation, verify that `(car (cons x y))'
yields `x' for any objects `x' and `y'.

(define (cons x y)
    (lambda (m) (m x y)))

(define (car z)
    (z (lambda (p q) p)))

What is the corresponding definition of `cdr'? (Hint: To verify
that this works, make use of the substitution model of section
*Note 1-1-5::.)
#+begin_src scheme
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src
** 2.5
*Exercise 2.5:* Show that we can represent pairs of nonnegative
integers using only numbers and arithmetic operations if we
represent the pair a and b as the integer that is the product 2^a
3^b.  Give the corresponding definitions of the procedures `cons',
`car', and `cdr'.
#+begin_src scheme :results output
(define (cons x y)
  (* (expt 2 x) (expt 3 y)))
(define (car z)
  (if (= (modulo z 2) 0)
      (1+ (car (/ z 2)))
      0))
(define (cdr z)
  (if (= (modulo z 3) 0)
      (1+ (cdr (/ z 3)))
      0))
(display (car (cons 4 12)))
(newline)
(display (cdr (cons 4 12)))

#+end_src

#+RESULTS:
: 4
: 12

** 2.6
*Exercise 2.6:* In case representing pairs as procedures wasn't
mind-boggling enough, consider that, in a language that can
manipulate procedures, we can get by without numbers (at least
insofar as nonnegative integers are concerned) by implementing 0
and the operation of adding 1 as

    (define zero (lambda (f) (lambda (x) x)))
    (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as "Church numerals", after its
inventor, Alonzo Church, the logician who invented the [lambda]
calculus.

Define `one' and `two' directly (not in terms of `zero' and
`add-1').  (Hint: Use substitution to evaluate `(add-1 zero)').
Give a direct definition of the addition procedure `+' (not in
terms of repeated application of `add-1').
#+begin_src scheme
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))))
(define two
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) f) x)))))
#+end_src
* 2.2
** 2.17
*Exercise 2.17:* Define a procedure `last-pair' that returns the
list that contains only the last element of a given (nonempty)
list:
    (last-pair (list 23 72 149 34))
    (34)
#+begin_src scheme
(define (last-pari l)
  (cond (((null? l) (error "l is not a list"))
         ((null? (cdr l)) (car l))
         (#t (last-pair (cdr l))))))
(define t (cons 1 (cons 2 '())))
(last-pair t)
#+end_src

#+RESULTS:
| 2 |
** 2.18
*Exercise 2.18:* Define a procedure `reverse' that takes a list as
argument and returns a list of the same elements in reverse order:
    (reverse (list 1 4 9 16 25))
    (25 16 9 4 1)
#+begin_src scheme :results raw
(define (reverse l)
  (define (reverse_iter l rv)
    (if (null? l)
        rv
        (reverse_iter (cdr l) (cons (car l) rv))))
  (reverse_iter l '()))

(reverse '(1 2 3 4 5 6 4))
#+end_src
** 2.19
*Exercise 2.19:* Consider the change-counting program of section
*Note 1-2-2::.  It would be nice to be able to easily change the
currency used by the program, so that we could compute the number
of ways to change a British pound, for example.  As the program is
written, the knowledge of the currency is distributed partly into
the procedure `first-denomination' and partly into the procedure
`count-change' (which knows that there are five kinds of U.S.
coins).  It would be nicer to be able to supply a list of coins to
be used for making change.

We want to rewrite the procedure `cc' so that its second argument
is a list of the values of the coins to use rather than an integer
specifying which coins to use.  We could then have lists that
defined each kind of currency:

(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1 0.5))

We could then call `cc' as follows:

(cc 100 us-coins)
292

To do this will require changing the program `cc' somewhat.  It
will still have the same form, but it will access its second
argument differently, as follows:

(define (cc amount coin-values)
(cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
        (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                    (first-denomination coin-values))
                coin-values)))))

Define the procedures `first-denomination',
`except-first-denomination', and `no-more?' in terms of primitive
operations on list structures.  Does the order of the list
`coin-values' affect the answer produced by `cc'?  Why or why not?
#+begin_src scheme
(define (cc amount coin-values)
(cond ((= amount 0) 1)
    ((or (< amount 0) (no-more? coin-values)) 0)
    (else
        (+ (cc amount
            (except-first-denomination coin-values))
        (cc (- amount
                (first-denomination coin-values))
            coin-values)))))
(define (first-denomination coin-values)
(car coin-values))
(define (except-first-denomination coin-values)
(cdr coin-values))
(define (no-more? coin-values)
(null? coin-values))

(cc 100 '(1 5 10 25 50))
#+end_src

#+RESULTS:
: 292
** 2.20
    *Exercise 2.20:* The procedures `+', `*', and `list' take
    arbitrary numbers of arguments. One way to define such procedures
    is to use `define' with notation "dotted-tail notation".  In a
    procedure definition, a parameter list that has a dot before the
    last parameter name indicates that, when the procedure is called,
    the initial parameters (if any) will have as values the initial
    arguments, as usual, but the final parameter's value will be a "list"
    of any remaining arguments.  For instance, given the definition

        (define (f x y . z) <BODY>)

    the procedure `f' can be called with two or more arguments.  If we
    evaluate

        (f 1 2 3 4 5 6)

    then in the body of `f', `x' will be 1, `y' will be 2, and `z'
    will be the list `(3 4 5 6)'.  Given the definition

        (define (g . w) <BODY>)

    the procedure `g' can be called with zero or more arguments.  If we
    evaluate

        (g 1 2 3 4 5 6)

    then in the body of `g', `w' will be the list `(1 2 3 4 5 6)'.(4)

    Use this notation to write a procedure `same-parity' that takes
    one or more integers and returns a list of all the arguments that
    have the same even-odd parity as the first argument.  For example,

        (same-parity 1 2 3 4 5 6 7)
        (1 3 5 7)

        (same-parity 2 3 4 5 6 7)
        (2 4 6)

#+begin_src scheme :results output
(define (same-parity a . w)
  (define (handle w rv)
    (cond ((null? w) rv)
           ((= (modulo a 2) (modulo (car w) 2)) (handle (cdr w) (cons (car w) rv)))
           (#t (handle (cdr w) rv))))
  (reverse (handle (cons a w) '())))

(display (same-parity 1 2 3 4 5 6 7 8 9))
#+end_src

#+RESULTS:
: (1 3 5 7 9)
