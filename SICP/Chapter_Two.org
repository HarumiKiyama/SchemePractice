# -*- mode: org; coding: utf-8 -*-
#+TITLE: SICP Chapter Two
#+STARTUP: overview

* 2.1
** 2.1
*Exercise 2.1:* Define a better version of `make-rat' that handles
both positive and negative arguments.  `Make-rat' should normalize
the sign so that if the rational number is positive, both the
numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.

#+begin_src scheme :results raw
(define (make-rat n d)
  (let* ((positive (or (and (<= n 0) (<= d 0))
                       (and (>= n 0) (>= d 0))))
         (g (gcd n d))
         (a (/ (if positive (abs n) (- (abs n))) g))
         (b (/ (abs d) g)))
    (cons a b)))

(make-rat -2 -4)
#+end_src
** 2.2
*Exercise 2.2:* Consider the problem of representing line segments
in a plane.  Each segment is represented as a pair of points: a
starting point and an ending point.  Define a constructor
`make-segment' and selectors `start-segment' and `end-segment'
that define the representation of segments in terms of points.
Furthermore, a point can be represented as a pair of numbers: the
x coordinate and the y coordinate.  Accordingly, specify a
constructor `make-point' and selectors `x-point' and `y-point'
that define this representation.  Finally, using your selectors
and constructors, define a procedure `midpoint-segment' that takes
a line segment as argument and returns its midpoint (the point
whose coordinates are the average of the coordinates of the
endpoints).  To try your procedures, you'll need a way to print
points:

(define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
   
#+begin_src scheme :results output
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

(define (make-segment beg end)
  (cons beg end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))

(define (mid-point-segment seg)
  (let* ((beg (start-segment seg))
         (end (end-segment seg))
         (beg_x (x-point beg))
         (beg_y (y-point beg))
         (end_x (x-point end))
         (end_y (y-point end)))
    (make-point (/ (+ beg_x end_x) 2)
                (/ (+ beg_y end_y) 2))
    )
  )

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(print-point (make-point 1 2))
#+end_src
** 2.3
*Exercise 2.3:* Implement a representation for rectangles in a
plane.  (Hint: You may want to make use of *Note Exercise 2-2::.)
In terms of your constructors and selectors, create procedures
that compute the perimeter and the area of a given rectangle.  Now
implement a different representation for rectangles.  Can you
design your system with suitable abstraction barriers, so that the
same perimeter and area procedures will work using either
representation?
#+begin_src scheme
(define (make-rectangle x y)
  (if (>= x y)
      (cons x y)
      (cons y x)))

(define (get-long r)
  (car x))

(define (get-short r)
  (cdr y))

(define (rec-area r)
  (* (get-long r)
     (get-short r)))

(define (rec-perimeter r)
  (+ (* 2 (get-long r))
     (* 2 (get-short r))))
#+end_src
** 2.4
*Exercise 2.4:* Here is an alternative procedural representation
of pairs.  For this representation, verify that `(car (cons x y))'
yields `x' for any objects `x' and `y'.

(define (cons x y)
    (lambda (m) (m x y)))

(define (car z)
    (z (lambda (p q) p)))

What is the corresponding definition of `cdr'? (Hint: To verify
that this works, make use of the substitution model of section
*Note 1-1-5::.)
#+begin_src scheme
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src
** 2.5
*Exercise 2.5:* Show that we can represent pairs of nonnegative
integers using only numbers and arithmetic operations if we
represent the pair a and b as the integer that is the product 2^a
3^b.  Give the corresponding definitions of the procedures `cons',
`car', and `cdr'.
#+begin_src scheme :results output
(define (cons x y)
  (* (expt 2 x) (expt 3 y)))
(define (car z)
  (if (= (modulo z 2) 0)
      (1+ (car (/ z 2)))
      0))
(define (cdr z)
  (if (= (modulo z 3) 0)
      (1+ (cdr (/ z 3)))
      0))
(display (car (cons 4 12)))
(newline)
(display (cdr (cons 4 12)))

#+end_src

#+RESULTS:
: 4
: 12

** 2.6
*Exercise 2.6:* In case representing pairs as procedures wasn't
mind-boggling enough, consider that, in a language that can
manipulate procedures, we can get by without numbers (at least
insofar as nonnegative integers are concerned) by implementing 0
and the operation of adding 1 as

    (define zero (lambda (f) (lambda (x) x)))
    (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as "Church numerals", after its
inventor, Alonzo Church, the logician who invented the [lambda]
calculus.

Define `one' and `two' directly (not in terms of `zero' and
`add-1').  (Hint: Use substitution to evaluate `(add-1 zero)').
Give a direct definition of the addition procedure `+' (not in
terms of repeated application of `add-1').
#+begin_src scheme
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))))
(define two
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) f) x)))))
#+end_src
* 2.2
** 2.17
*Exercise 2.17:* Define a procedure `last-pair' that returns the
list that contains only the last element of a given (nonempty)
list:
    (last-pair (list 23 72 149 34))
    (34)
#+begin_src scheme
(define (last-pari l)
  (cond (((null? l) (error "l is not a list"))
         ((null? (cdr l)) (car l))
         (#t (last-pair (cdr l))))))
(define t (cons 1 (cons 2 '())))
(last-pair t)
#+end_src

#+RESULTS:
| 2 |
** 2.18
*Exercise 2.18:* Define a procedure `reverse' that takes a list as
argument and returns a list of the same elements in reverse order:
    (reverse (list 1 4 9 16 25))
    (25 16 9 4 1)
#+begin_src scheme :results raw
(define (reverse l)
  (define (reverse_iter l rv)
    (if (null? l)
        rv
        (reverse_iter (cdr l) (cons (car l) rv))))
  (reverse_iter l '()))

(reverse '(1 2 3 4 5 6 4))
#+end_src
** 2.19
*Exercise 2.19:* Consider the change-counting program of section
*Note 1-2-2::.  It would be nice to be able to easily change the
currency used by the program, so that we could compute the number
of ways to change a British pound, for example.  As the program is
written, the knowledge of the currency is distributed partly into
the procedure `first-denomination' and partly into the procedure
`count-change' (which knows that there are five kinds of U.S.
coins).  It would be nicer to be able to supply a list of coins to
be used for making change.

We want to rewrite the procedure `cc' so that its second argument
is a list of the values of the coins to use rather than an integer
specifying which coins to use.  We could then have lists that
defined each kind of currency:

(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1 0.5))

We could then call `cc' as follows:

(cc 100 us-coins)
292

To do this will require changing the program `cc' somewhat.  It
will still have the same form, but it will access its second
argument differently, as follows:

(define (cc amount coin-values)
(cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
        (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                    (first-denomination coin-values))
                coin-values)))))

Define the procedures `first-denomination',
`except-first-denomination', and `no-more?' in terms of primitive
operations on list structures.  Does the order of the list
`coin-values' affect the answer produced by `cc'?  Why or why not?
#+begin_src scheme
(define (cc amount coin-values)
(cond ((= amount 0) 1)
    ((or (< amount 0) (no-more? coin-values)) 0)
    (else
        (+ (cc amount
            (except-first-denomination coin-values))
        (cc (- amount
                (first-denomination coin-values))
            coin-values)))))
(define (first-denomination coin-values)
(car coin-values))
(define (except-first-denomination coin-values)
(cdr coin-values))
(define (no-more? coin-values)
(null? coin-values))

(cc 100 '(1 5 10 25 50))
#+end_src

#+RESULTS:
: 292
** 2.20
    *Exercise 2.20:* The procedures `+', `*', and `list' take
    arbitrary numbers of arguments. One way to define such procedures
    is to use `define' with notation "dotted-tail notation".  In a
    procedure definition, a parameter list that has a dot before the
    last parameter name indicates that, when the procedure is called,
    the initial parameters (if any) will have as values the initial
    arguments, as usual, but the final parameter's value will be a "list"
    of any remaining arguments.  For instance, given the definition

        (define (f x y . z) <BODY>)

    the procedure `f' can be called with two or more arguments.  If we
    evaluate

        (f 1 2 3 4 5 6)

    then in the body of `f', `x' will be 1, `y' will be 2, and `z'
    will be the list `(3 4 5 6)'.  Given the definition

        (define (g . w) <BODY>)

    the procedure `g' can be called with zero or more arguments.  If we
    evaluate

        (g 1 2 3 4 5 6)

    then in the body of `g', `w' will be the list `(1 2 3 4 5 6)'.(4)

    Use this notation to write a procedure `same-parity' that takes
    one or more integers and returns a list of all the arguments that
    have the same even-odd parity as the first argument.  For example,

        (same-parity 1 2 3 4 5 6 7)
        (1 3 5 7)

        (same-parity 2 3 4 5 6 7)
        (2 4 6)

#+begin_src scheme :results output
(define (same-parity a . w)
  (define (handle w rv)
    (cond ((null? w) rv)
           ((= (modulo a 2) (modulo (car w) 2)) (handle (cdr w) (cons (car w) rv)))
           (#t (handle (cdr w) rv))))
  (reverse (handle (cons a w) '())))

(display (same-parity 1 2 3 4 5 6 7 8 9))
#+end_src

#+RESULTS:
: (1 3 5 7 9)
** 2.21
*Exercise 2.21:* The procedure `square-list' takes a list of
numbers as argument and returns a list of the squares of those
numbers.

    (square-list (list 1 2 3 4))
    (1 4 9 16)

Here are two different definitions of `square-list'.  Complete
both of them by filling in the missing expressions:

    (define (square-list items)
    (if (null? items)
        nil
        (cons <??> <??>)))

    (define (square-list items)
    (map <??> <??>))
#+begin_src scheme
(define nil '())

(define (square-list items)
  (if (null? items)
      nil
      (cons (* (car items) (car items)) (square-list (cdr items)))))

(define (square-list items)
  (map (lambda (x) (* x x)) items))

(square-list '(1 2 3 4 5))
#+end_src
** 2.25
*Exercise 2.25:* Give combinations of `car's and `cdr's that will
pick 7 from each of the following lists:

    (1 3 (5 7) 9)

    ((7))

    (1 (2 (3 (4 (5 (6 7))))))
   
#+begin_src scheme :results output
(define first '(1 3 (5 7) 9
                  ))
(define second '((7)))
(define third '(1 (2 (3 (4 (5 (6 7)))))))
(display (cadar (cddr first)))
(newline)
(display (caar second))
(newline)
(display (cadadr  (cadadr (cadadr third))))
#+end_src
** 2.26
*Exercise 2.26:* Suppose we define `x' and `y' to be two lists:

    (define x (list 1 2 3))

    (define y (list 4 5 6))

What result is printed by the interpreter in response to
evaluating each of the following expressions:

    (append x y)

    (cons x y)

    (list x y)
#+begin_src scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+end_src
** 2.27
*Exercise 2.27:* Modify your `reverse' procedure of *Note Exercise
2-18:: to produce a `deep-reverse' procedure that takes a list as
argument and returns as its value the list with its elements
reversed and with all sublists deep-reversed as well.  For example,

    (define x (list (list 1 2) (list 3 4)))

    x
    ((1 2) (3 4))

    (reverse x)
    ((3 4) (1 2))

    (deep-reverse x)
    ((4 3) (2 1))
#+begin_src scheme :results output
(define x (list (list 1 2) (list 3 4)))

(define (reverse l)
  (define (reverse_iter l rv)
    (cond ((null? l) rv)
          ((not (pair? (car l))) (reverse_iter (cdr l) (cons (car l) rv)))
          (else (reverse_iter (cdr l) (cons (reverse_iter (car l) #nil) rv)))))
  (reverse_iter l #nil))

(display  (reverse x))


#+end_src

#+RESULTS:
: ((4 3) (2 1))

** 2.28
*Exercise 2.28:* Write a procedure `fringe' that takes as argument
a tree (represented as a list) and returns a list whose elements
are all the leaves of the tree arranged in left-to-right order.
For example,

    (define x (list (list 1 2) (list 3 4)))

    (fringe x)
    (1 2 3 4)

    (fringe (list x x))
    (1 2 3 4 1 2 3 4)

#+begin_src scheme :results raw
(define x (list (list 1 2) (list 3 4)))

(define (fringe x)
  (cond (
         (null? x) #nil)
        ((pair? (car x)) (append (fringe (car x)) (fringe (cdr x))))
        (else (cons (car x) (fringe (cdr x))))))
(fringe x)
#+end_src

#+RESULTS:
(1 2 3 4)
** 2.29
*Exercise 2.29:* A binary mobile consists of two branches, a left
branch and a right branch.  Each branch is a rod of a certain
length, from which hangs either a weight or another binary mobile.
We can represent a binary mobile using compound data by
constructing it from two branches (for example, using `list'):

    (define (make-mobile left right)
    (list left right))

A branch is constructed from a `length' (which must be a number)
together with a `structure', which may be either a number
(representing a simple weight) or another mobile:

    (define (make-branch length structure)
    (list length structure))

a. Write the corresponding selectors `left-branch' and
    `right-branch', which return the branches of a mobile, and
    `branch-length' and `branch-structure', which return the
    components of a branch.
#+begin_src scheme :session mobile
(define (left-branch m)
  (car m))
(define (right-branch m)
  (cadr m))

(define (branch-length b)
  (car b))
(define (branch-structure b)
  (cadr b))
#+end_src

b. Using your selectors, define a procedure `total-weight' that
    returns the total weight of a mobile.
#+begin_src scheme :session mobile
(define mobile '((1 ((1 3) (2 4))) (1 3)))

(define (total-weight m)
  (let* ((left (branch-structure (left-branch m)))
         (right (branch-structure (right-branch m)))
         (left-weight (if (pair? left) (total-weight left) left))
         (right-weight (if (pair? right) (total-weight right) right)))
    (+ right-weight left-weight)))

(total-weight mobile)
#+end_src

#+RESULTS:
: 10

c. A mobile is said to be "balanced" if the torque applied by
    its top-left branch is equal to that applied by its top-right
    branch (that is, if the length of the left rod multiplied by
    the weight hanging from that rod is equal to the
    corresponding product for the right side) and if each of the
    submobiles hanging off its branches is balanced. Design a
    predicate that tests whether a binary mobile is balanced.
#+begin_src scheme :session mobile
(define (mobile-balance? m)
  (let* ((left (left-branch m))
         (right (right-branch m))
         (left-balance (if (pair? (branch-structure left))
                           (mobile-balance? (branch-structure left))
                           #t))
         (right-balance (if (pair? (branch-structure right))
                            (mobile-balance? (branch-structure right))
                            #t))
         (left-product (* (branch-length left)
                          (if (pair? (branch-structure left))
                              (total-weight (branch-structure left))
                              (branch-structure left))))
         (right-product (* (branch-length right)
                           (if (pair? (branch-structure right))
                               (total-weight (branch-structure right))
                               (branch-structure right)))))
    (and left-balance right-balance (= left-product right-product))))

(mobile-balance? mobile)
#+end_src

d. Suppose we change the representation of mobiles so that the constructors are
        (define (make-mobile left right)
            (cons left right))

        (define (make-branch length structure)
            (cons length structure))

    How much do you need to change your programs to convert to
    the new representation?
** 2.30
*Exercise 2.30:* Define a procedure `square-tree' analogous to the
`square-list' procedure of *Note Exercise 2-21::.  That is,
`square-list' should behave as follows:

    (square-tree
    (list 1
            (list 2 (list 3 4) 5)
            (list 6 7)))
    (1 (4 (9 16) 25) (36 49))

Define `square-tree' both directly (i.e., without using any
higher-order procedures) and also by using `map' and recursion.
#+begin_src scheme :results raw
(define (square-tree tree)
  (map (lambda (sub)
         (if (pair? sub)
             (square-tree sub)
             (* sub sub))) tree))

(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
#+end_src

#+RESULTS:
(1 (4 (9 16) 25) (36 49))
** 2.31
*Exercise 2.31:* Abstract your answer to *Note Exercise 2-30:: to
produce a procedure `tree-map' with the property that
`square-tree' could be defined as
    (define (square-tree tree) (tree-map square tree))
#+name: answer
#+begin_src scheme :session tree-map
(define (tree-map proc tree)
  (map (lambda (sub)
         (if (pair? sub)
             (tree-map proc sub)
             (proc sub)))
       tree))
#+end_src

#+begin_src scheme :session tree-map
(define (square x) (* x x))
(define (square-tree tree) (tree-map square tree))
(square-tree '(1 2 (1 3 2 (1 2 3 4)) (1 2 3 )))

#+end_src
** 2.32
*Exercise 2.32:* We can represent a set as a list of distinct
elements, and we can represent the set of all subsets of the set as
a list of lists.  For example, if the set is `(1 2 3)', then the
set of all subsets is `(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2
3))'.  Complete the following definition of a procedure that
generates the set of subsets of a set and give a clear explanation
of why it works:

    (define (subsets s)
    (if (null? s)
        (list nil)
        (let ((rest (subsets (cdr s))))
            (append rest (map <??> rest)))))
#+begin_src scheme
(define (subsets s)
    (if (null? s)
        (list #nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x) (cons (car s) x)) rest)))))

(subsets '(1 2 3))
#+end_src

#+RESULTS:
(#nil (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
** 2.33
*Exercise 2.33:* Fill in the missing expressions to complete the
following definitions of some basic list-manipulation operations
as accumulations:

    (define (map p sequence)
    (accumulate (lambda (x y) <??>) nil sequence))

    (define (append seq1 seq2)
    (accumulate cons <??> <??>))

    (define (length sequence)
    (accumulate <??> 0 sequence))
#+begin_src scheme :results output :session accumulate
(define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) #nil sequence))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(define (length sequence)
  (accumulate (lambda (x y) (1+ y)) 0 sequence))

(display (map (lambda (x) (* x x)) '(1 2 3 4 5 6)))
(newline)
(display (append '(1 2 3) '(4 5 6)))
(newline)
(display (length '(1 2 3 4 5 6)))
#+end_src

#+RESULTS:
(1 4 9 16 25 36)
(1 2 3 4 5 6)
6

** 2.34
*Exercise 2.34:* Evaluating a polynomial in x at a given value of
x can be formulated as an accumulation.  We evaluate the polynomial

    a_n r^n | a_(n-1) r^(n-1) + ... + a_1 r + a_0

using a well-known algorithm called "Horner's rule", which
structures the computation as

    (... (a_n r + a_(n-1)) r + ... + a_1) r + a_0

In other words, we start with a_n, multiply by x, add a_(n-1),
multiply by x, and so on, until we reach a_0.(3)

Fill in the following template to produce a procedure that
evaluates a polynomial using Horner's rule.  Assume that the
coefficients of the polynomial are arranged in a sequence, from
a_0 through a_n.

    (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms) <??>)
                0
                coefficient-sequence))

For example, to compute 1 + 3x + 5x^3 + x^(5) at x = 2 you would evaluate
    (horner-eval 2 (list 1 3 0 5 0 1))
#+begin_src scheme :session accumulate
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* higher-terms x)))
              0
              coefficient-sequence))

(horner-eval 2 '(1 3 0 5 0 1))
#+end_src
** 2.35
*Exercise 2.35:* Redefine `count-leaves' from section *Note
2-2-2:: as an accumulation:

    (define (count-leaves t)
    (accumulate <??> <??> (map <??> <??>)))
#+begin_src scheme
(define (accumulate op initial sequence)
       (if (null? sequence)
           initial
           (op (car sequence)
               (accumulate op initial (cdr sequence)))))

(define (count-leaves t)
  (accumulate  + 0
               (map (lambda (x)
                      (cond ((null? x) 0)
                            ((pair? x) (count-leaves x))
                            (else 1))
                      ) t)))

(count-leaves '(1 (12 3 4 5) 2 3 (2 3 4 5 )))
#+end_src
** 2.36
*Exercise 2.36:* The procedure `accumulate-n' is similar to
`accumulate' except that it takes as its third argument a sequence
of sequences, which are all assumed to have the same number of
elements.  It applies the designated accumulation procedure to
combine all the first elements of the sequences, all the second
elements of the sequences, and so on, and returns a sequence of
the results.  For instance, if `s' is a sequence containing four
sequences, `((1 2 3) (4 5 6) (7 8 9) (10 11 12)),' then the value
of `(accumulate-n + 0 s)' should be the sequence `(22 26 30)'.
Fill in the missing expressions in the following definition of
`accumulate-n':

    (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        nil
        (cons (accumulate op init <??>)
                (accumulate-n op init <??>))))
               
#+begin_src scheme :session accumulate
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      #nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#+end_src

** 2.37
#+begin_src scheme :session accumulate
(define (zip v w)
  (if (null? v)
      #nil
      (cons ((car v) (car w)) (zip (cdr v) (cdr w)))))

(define (dot-product v w)
  (accumulate + 0 (map (lambda (x)
                         (let ((a (car x))
                               (b (cdr x)))
                           (* a b))) (zip v w))))

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product v x)) m))

(define (transpose mat)
  (accumulate-n cons #nil mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (x) (dot-product x cols)) m)))
#+end_src
** 2.38
#+begin_src scheme :results output :session fold
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (fold-right op initial (cdr sequence)))))

(display (fold-right / 1 (list 1 2 3 4)))
(newline)
(display (fold-left / 1 (list 1 2 3)))
(newline)
(display (fold-right list #nil (list 1 2 3)))
(newline)
(display (fold-left list #nil (list 1 2 3)))
(newline)
(display (fold-right + 0 '(1 2 3 4 5)))
(newline)
(display (fold-right + 0 '(1 2 3 4 5)))
#+end_src

#+RESULTS:
: 3/8
: 1/6
: (1 (2 (3 #nil)))
: (((#nil 1) 2) 3)
: 15
: 15
** 2.39
*Exercise 2.39:* Complete the following definitions of `reverse'
(*Note Exercise 2-18::) in terms of `fold-right' and `fold-left'
from *Note Exercise 2-38:::

    (define (reverse sequence)
    (fold-right (lambda (x y) <??>) nil sequence))

    (define (reverse sequence)
    (fold-left (lambda (x y) <??>) nil sequence))
   
#+begin_src scheme :results output :session fold
(define (reverse-r sequence)
  (fold-right (lambda (x y) (append y (list x))) '() sequence))

(define (reverse-l sequence)
  (fold-left (lambda (x y) (cons y x)) '() sequence))

(display (reverse-r '(1 2 3 4 5 6)))
(newline)
(display (reverse-l '(1 2 3 4 5 6)))

#+end_src

#+RESULTS:
: (6 5 4 3 2 1)
: (6 5 4 3 2 1)
** 2.40
*Exercise 2.40:* Define a procedure `unique-pairs' that, given an
integer n, generates the sequence of pairs (i,j) with 1 <= j< i <=
n.  Use `unique-pairs' to simplify the definition of
`prime-sum-pairs' given above.
#+begin_src scheme :session flatmap :results output
(use-srfis '(1))
(define (enumerate-interval beg end)
  (if (> beg end)
      '()
      (cons beg (enumerate-interval (1+ beg) end))))

(define (flatmap proc seq)
  (fold-right append '() (map proc seq)))

(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval (1+ i) n)))
   (enumerate-interval 1 (- n 1))))

(display (unique-pairs 5))
#+end_src

#+RESULTS:
: ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5))

** 2.41
*Exercise 2.41:* Write a procedure to find all ordered triples of distinct
positive integers i, j, and k less than or equal to a given integer n that sum
to a given integer s.
#+begin_src scheme :session flatmap :results raw
(define (unique-triples n)
  (flatmap (lambda (i)
         (flatmap (lambda (j)
                (map (lambda (k)
                       (list i j k))
                     (enumerate-interval 1 (- j 1))))
              (enumerate-interval 2 (- i 1)))) (enumerate-interval 3 n)))

(define (triples n s)
  (filter (lambda (i) (= s (+ (car i) (cadr i) (caddr i))))
          (unique-triples n)))


(triples 10 17)
#+end_src

#+RESULTS:
((7 6 4) (8 5 4) (8 6 3) (8 7 2) (9 5 3) (9 6 2) (9 7 1) (10 4 3) (10 5 2) (10 6 1))
** 2.42
#+begin_src scheme :session flatmap :results raw
(define (safe-two x y)
  (let ((row-x (car x))
        (row-y (car y))
        (col-x (cadr x))
        (col-y (cadr y)))
    (if (= row-x row-y) #f
        (not (= (abs (/ (- col-x col-y) (- row-x row-y))) 1)))))

(define (safe? k positions)
  (let ((position (car positions))
        (rest (cdr positions)))
    ;; check whether same row
    (fold (lambda (x y) (and y (safe-two x position)) ) #t rest)))

(display (safe? 8 '((1 2) (3 3 ) (4 4))))

(define (adjoin-position new-row k rest-of-queens)
  (cons  (list new-row k) rest-of-queens))

(define empty-board '())

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(length (queens 8))
#+end_src

#+RESULTS:
92
** 2.43
[[https://wernerdegroot.wordpress.com/2015/08/01/sicp-exercise-2-43/][other's solution]]
** 2.44
#+begin_src scheme :session painter
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let* ((up (up-split painter (- n 1)))
             (right (right-split painter (- n 1)))
             (top-left (beside up up))
             (bottom-right (below right right))
             (corner (corner-split painter (- n 1))))
        (beside (below painter top-left)
                (below bottom-right corner)))))

(define (square-limit painter n)
  (let* ((quarter (corner-split painter n))
         (half (beside (flip-horiz quarter) quarter)))
    (below (flip-vert half) half)))

(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
#+end_src
*Exercise 2.44:* Define the procedure `up-split' used by
`corner-split'.  It is similar to `right-split', except that it switches the
roles of `below' and `beside'.
#+begin_src scheme :session painter
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((upper (up-split painter (1- n))))
        (below painter (beside painter upper))
        )))
#+end_src
** 2.45
*Exercise 2.45:* `Right-split' and `up-split' can be expressed as instances
of a general splitting operation.  Define a procedure `split' with the
property that evaluating
    (define right-split (split beside below))
    (define up-split (split below beside))
produces procedures `right-split' and `up-split' with the same behaviors as the
ones already defined.
#+begin_src scheme
(define (split f1 f2)
  (define (helper painter n)
    (if (= n 0)
        painter
        (let ((part (helper painter (1- n))))
          (f1 painter (f2 painter part))))))
#+end_src

** 2.46
*Exercise 2.46:* A two-dimensional vector v running from the origin to a point
can be represented as a pair consisting of an x-coordinate and a y-coordinate.
Implement a data abstraction for vectors by giving a constructor `make-vect' and
corresponding selectors `xcor-vect' and `ycor-vect'.  In terms of your selectors
and constructor, implement procedures `add-vect', `sub-vect', and `scale-vect'
that perform the operations vector addition, vector subtraction, and multiplying
a vector by a scalar:
    (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
    (x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
    s * (x, y) = (sx, sy)
#+begin_src scheme :session painter
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2))
             (+ (ycor-vect v1) (ycor-vect v2))))

(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2))
             (- (ycor-vect v1) (ycor-vect v2))))

(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+end_src
** 2.48
*Exercise 2.48:* A directed line segment in the plane can be represented as a
pair of vectors--the vector running from the origin to the start-point of the
segment, and the vector running from the origin to the end-point of the segment.
Use your vector representation from *Note Exercise 2-46:: to define a
representation for segments with a constructor `make-segment' and selectors
`start-segment' and `end-segment'.
#+begin_src scheme :session painter
(define (make-segment v1 v2)
  (cons v1 v2))

(define (start-segment s)
  (car s))

(define (end-segment s)
  (cdr s))
#+end_src
** 2.49
*Exercise 2.49:* Use `segments->painter' to define the following primitive
painters:
    a. The painter that draws the outline of the designated frame.
    b. The painter that draws an "X" by connecting opposite corners of the
    frame.
    c. The painter that draws a diamond shape by connecting the midpoints of the
    sides of the frame.
    d. The `wave' painter.
   
#+begin_src scheme :session painter
(define (segments->painter segment-list))

(define (frame-origin frame))
(define (frame-edge1 frame))
(define (frame-edge2 frame))

;; TODO: complete this
(define (frame-outline frame)
  (let* ((base (make-vect 0 0))
         (left (frame-edge1 frame))
         (right (frame-edge2 frame))
         (top (add-vect left right))
         (segment1 (make-segment base left))
         (segment2 (make-segment base right))
         (segment3 (make-segment top left))
         (segment4 (make-segment top right)))
    (segments->painter (list segment1 segment2 segment3 segment4))))

(define (frame-X frame)
  (let* ((base (make-vect 0 0))
         (left (frame-edge1 frame))
         (right (frame-edge2 frame))
         (top (add-vect left right))
         (segment1 (make-segment base top))
         (segment2 (make-segment left right)))
    (segments->painter (list segment1 segment2))))

(define (frame-diamond frame)
  (let* ((left (frame-edge1 frame))
         (right (frame-edge2 frame))
         (p1 (scale-vect left))
         (p2 (scale-vect right))
         (p3 (add-vect p1 right))
         (p4 (add-vect p2 left))
         (segment1 (make-segment p1 p2))
         (segment2 (make-segment p3 p4))
         (segment3 (make-segment p1 p4))
         (segment4 (make-segment p2 p 3)))
    (segments->painter (list segment1 segment2 segment3 segment4))))
(define (frame-wave frame))
#+end_src
** 2.50
*Exercise 2.50:* Define the transformation `flip-horiz', which flips painters
horizontally, and transformations that rotate painters counterclockwise by 180
degrees and 270 degrees.
#+begin_src scheme :session painter
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))

(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))

(define (flip-rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))

(define (flip-rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
#+end_src
** 2.51
*Exercise 2.51:* Define the `below' operation for painters.
#+begin_src scheme :session painter
(define (below painter1 painter2)
  (let* ((spilt-point (make-vect 0.0 0.5))
         (paint-down (transform-painter painter1
                                        (make-vect 0.0)
                                        split-point
                                        (make-vect 0.0 1.0)))
         (paint-up (transform-painter painter2
                                      split-point
                                      (make-vect 0.0 0.5)
                                      (make-vect 1.0 0.0))))
    (lambda (frame)
      (paint-up frame)
      (paint-down frame))))
#+end_src

#+begin_src scheme :session painter
(define (below painter1 painter2)
  (lambda (frame)
    (flip-rotate90 (beside (flip-rotate270 painter1) (flip-rotate270 painter2)))))
#+end_src
* 2.3
** 2.54
#+begin_src scheme
(define (equal? x y)
  (cond ((and (null? x) (null? y)) #t)
        ((or (null? x) (null? y)) #f)
        ((and (pair? (car x)) (pair? (car y)))
         (and (equal? (car x) (car y)) (equal? (cdr x) (cdr y))))
        ((or (pair? (car x)) (pair? (car y))) #f)
        (else (and (eq? (car x) (car y))
                   (equal? (cdr x) (cdr y))))))

(equal? '(1 2 (5) 3 4) '(1 2 (5) 3 4))
#+end_src
** 2.55
*Exercise 2.55:* Eva Lu Ator types to the interpreter the
expression

    (car ''abracadabra)

To her surprise, the interpreter prints back `quote'.  Explain.
#+begin_comment
The guile compiler treat the value of ''abracadabra as '(abracadabra)
#+end_comment
** 2.56
*Exercise 2.56:* Show how to extend the basic differentiator to
handle more kinds of expressions.  For instance, implement the
differentiation rule

    n_1   n_2
    --- = ---  if and only if n_1 d_2 = n_2 d_1
    d_1   d_2

by adding a new clause to the `deriv' program and defining
appropriate procedures `exponentiation?', `base', `exponent', and
`make-exponentiation'.  (You may use the symbol `**' to denote
exponentiation.)  Build in the rules that anything raised to the
power 0 is 1 and anything raised to the power 1 is the thing
itself.
#+begin_src scheme :session differentiation :results raw
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (base p) (cadr p))
(define (exponent p) (caddr p))

(define (make-exponentiation base exponent)
  (cond ((=number? base 0) 0)
        ((=number? base 1) 1)
        ((=number? exponent 0) 1)
        ((and (number? base) (number? exponent)) (expt base exponent))
        (else (list '** base exponent))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((and (exponentiation? exp) (number? (exponent exp)))  (make-product
                                (make-product
                                 (exponent exp)
                                 (make-exponentiation
                                  (base exp)
                                  (make-sum (exponent exp) -1)))
                                (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(deriv '(* x y) 'x)
#+end_src

#+RESULTS:
y

** 2.57
*Exercise 2.57:* Extend the differentiation program to handle sums
and products of arbitrary numbers of (two or more) terms.  Then
the last example above could be expressed as

    (deriv '(* x y (+ x 3)) 'x)

Try to do this by changing only the representation for sums and
products, without changing the `deriv' procedure at all.  For
example, the `addend' of a sum would be the first term, and the
`augend' would be the sum of the rest of the terms.
#+begin_src scheme :session differentiation
(define (addend s) (cadr s))
(define (augend s)
  (if (null? (cdddr s))
      (caddr s)
      (cons '+ (cddr s))))

(define (multiplier p) (cadr p))
(define (multiplicand p)
  (if (null? (cdddr p))
      (caddr p)
      (cons '* (cddr p))))

(deriv '(* x y) 'x)
#+end_src

** 2.58
*Exercise 2.58:* Suppose we want to modify the differentiation
program so that it works with ordinary mathematical notation, in
which `+' and `*' are infix rather than prefix operators.  Since
the differentiation program is defined in terms of abstract data,
we can modify it to work with different representations of
expressions solely by changing the predicates, selectors, and
constructors that define the representation of the algebraic
expressions on which the differentiator is to operate.

a. Show how to do this in order to differentiate algebraic
    expressions presented in infix form, such as `(x + (3 * (x +
    (y + 2))))'.  To simplify the task, assume that `+' and `*'
    always take two arguments and that expressions are fully
    parenthesized.
#+begin_src scheme :session differentiation
(define (sum? exp)
  (and (pair? exp)
       (eq? (cadr exp) '+)))

(define (addend exp) (car exp))
(define (augend exp) (caddr exp))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+  a2))))


(define (product? exp)
  (and (pair? exp)
       (eq? (cadr exp) '*)))

(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))



(deriv '(x * (x * y)) 'x)
#+end_src

b. The problem becomes substantially harder if we allow standard
    algebraic notation, such as `(x + 3 * (x + y + 2))', which
    drops unnecessary parentheses and assumes that multiplication
    is done before addition.  Can you design appropriate
    predicates, selectors, and constructors for this notation
    such that our derivative program still works?

#+begin_src scheme :session differentiation
(define (addend exp) (car exp))
(define (augend exp)
  (if (null? (cdddr exp) )
      (caddr exp)
      (cddr exp)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+  a2))))

(define (multiplier exp)
  (car exp))
(define (multiplicand exp)
  (if (null? (cdddr exp))
      (caddr exp)
      (cddr exp)))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))

(deriv '(x * (x + y)) 'x)
#+end_src
** 2.59
*Exercise 2.59:* Implement the `union-set' operation for the unordered-list representation of sets.
#+begin_src scheme :session set
(define (element-of-set? x set)
       (cond ((null? set) #f)
             ((equal? x (car set)) #t)
             (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
       (if (element-of-set? x set)
           set
           (cons x set)))
(define (intersection-set set1 set2)
       (cond ((or (null? set1) (null? set2)) '())
             ((element-of-set? (car set1) set2)
              (cons (car set1)
                    (intersection-set (cdr set1) set2)))
             (else (intersection-set (cdr set1) set2))))

(define (union-set s1 s2)
  (cond ((null? s1) s2)
        ((null? s2) s1)
        (else (union-set (cdr s1) (adjoin-set (car s1) s2)))))

(union-set '(1 2 3 4 5) '(1 2 3 6))
#+end_src
** 2.60
*Exercise 2.60:* We specified that a set would be represented as a
list with no duplicates.  Now suppose we allow duplicates.  For
instance, the set {1,2,3} could be represented as the list `(2 3 2
1 3 2 2)'.  Design procedures `element-of-set?', `adjoin-set',
`union-set', and `intersection-set' that operate on this
representation.  How does the efficiency of each compare with the
corresponding procedure for the non-duplicate representation?  Are
there applications for which you would use this representation in
preference to the non-duplicate one?
#+begin_src scheme :session set
(define (element-of-set? x set)
  (and (not (null? set))
       (or (equal? x (car set)) (element-of-set? x (cdr set)))))


(define (union-set s1 s2)
  (append s1 s2))

(define (adjoin-set x set)
  (cons x set))

(define (intersection-set s1 s2)
  (cond ((or (null? s1) (null? s2)) '())
        ((element-of-set? (car s1) s2)
         (cons (car s1) (intersection-set (cdr s1) s2)))
        (else (intersection-set (cdr s1) s2))))
#+end_src
** 2.61
*Exercise 2.61:* Give an implementation of `adjoin-set' using the
ordered representation.  By analogy with `element-of-set?' show
how to take advantage of the ordering to produce a procedure that
requires on the average about half as many steps as with the
unordered representation.
#+begin_src scheme
(define (adjoin-set x set)
  (cond ((null? set) '(x))
        ((< x (car set)) (cons x set))
        ((= x (car set)) set)
        (else (cons (car set) (adjoin-set x (cdr set))))))

(adjoin-set 1 '(1 2 3))
#+end_src

** 2.62
*Exercise 2.62:* Give a [theta](n) implementation of `union-set'
for sets represented as ordered lists.
#+begin_src scheme
(define (union-set s1 s2)
  (cond ((null? s1) s2)
        ((null? s2) s1)
        ((= (car s1) (car s2))
         (cons (car s1)
               (union-set (cdr s1) (cdr s2))))
        ((< (car s1) (car s2))
         (cons (car s1) (union-set (cdr s1) s2)))
        (else (cons (car s2) (union-set s1 (cdr s2))))))

(union-set '(1 2 3) '(1 4 5 6))
#+end_src
** 2.63
#+begin_src scheme :session tree
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
       (list entry left right))
#+end_src
*Exercise 2.63:* Each of the following two procedures converts a
binary tree to a list.


a. Do the two procedures produce the same result for every tree?
If not, how do the results differ?  What lists do the two
procedures produce for the trees in *Note Figure 2-16::?
#+begin_src scheme :session tree :results output
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
#+end_src

#+begin_comment
The two procedures do produce the same results
#+end_comment

b. Do the two procedures have the same order of growth in the
number of steps required to convert a balanced tree with n
elements to a list?  If not, which one grows more slowly?
#+begin_comment
The two procedures do have the same order of growth in the number of steps
#+end_comment
** 2.64
#+begin_src scheme :session tree
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let* ((left-size (quotient (- n 1) 2))
             (left-result (partial-tree elts left-size))
             (left-tree (car left-result))
             (non-left-elts (cdr left-result))
             (right-size (- n (+ left-size 1)))
             (this-entry (car non-left-elts))
             (right-result (partial-tree
                            (cdr non-left-elts)
                            right-size))
             (right-tree (car right-result))
             (remaining-elts (cdr right-result)))
        (cons (make-tree this-entry left-tree right-tree)
              remaining-elts))))
#+end_src

#+begin_comment
The procedure's order of growth is $\Theta(n)$
#+end_comment
** 2.65
*Exercise 2.65:* Use the results of *Note Exercise 2-63:: and *Note Exercise
2-64:: to give [theta](n) implementations of `union-set' and `intersection-set'
for sets implemented as (balanced) binary trees.(5)
 #+begin_src scheme :session tree
(define (union-tree t1 t2)
  (list->tree (union-set (tree->list-2 t1)
                         (tree->list-2 t2))))

(define (intersection-tree t1 t2)
  (list->tree (intersection-set (tree->list-2 t1)
                                (tree->list-2 t2))))
 #+end_src
** 2.66
*Exercise 2.66:* Implement the `lookup' procedure for the case where the set of
records is structured as a binary tree, ordered by the numerical values of the
keys.
#+begin_src scheme :session tree
(define (lookup k tree)
  (cond
   ((null? tree) #f)
   ((key-equal? k (key (entry tree))) (entry tree))
   ((key-large? k (key (entry tree))) (lookup k (right-branch tree)))
   (else (lookup k (left-branch tree)))))
#+end_src
** 2.67
#+begin_src scheme :session haffman
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))

(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))

(define (right-branch tree) (cadr tree))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x)
            (weight (car set)))
         (cons x set))
        (else
         (cons (car set)
               (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair) ; symbol
                               (cadr pair)) ; frequency
                    (make-leaf-set (cdr pairs))))))
#+end_src

*Exercise 2.67:* Define an encoding tree and a sample message:
#+begin_src scheme :session haffman
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+end_src

Use the `decode' procedure to decode the message, and give the result.
#+begin_src scheme :session haffman :results raw
(decode sample-message sample-tree)
#+end_src

#+RESULTS:
(A D A B B C A)
** 2.68
*Exercise 2.68:* The `encode' procedure takes as arguments a
message and a tree and produces the list of bits that gives the
encoded message.
#+begin_src scheme :session haffman
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
#+end_src

`Encode-symbol' is a procedure, which you must write, that returns
the list of bits that encodes a given symbol according to a given
tree.  You should design `encode-symbol' so that it signals an
error if the symbol is not in the tree at all.  Test your
procedure by encoding the result you obtained in *Note Exercise
2-67:: with the sample tree and seeing whether it is the same as
the original sample message.
#+begin_src scheme :session haffman :results raw
(define (encode-symbol c tree)
  (if (not (memq c (symbols tree)))
      (error "not in tree"))
  (if (leaf? tree)
      '()
      (let* ((left (left-branch tree))
             (right (right-branch tree))
             (left-symbols (symbols left))
             (right-symbols (symbols right)))
        (if (memq c left-symbols)
            (cons 0 (encode-symbol c left))
            (cons 1 (encode-symbol c right))))))
(encode '(A D A B B C A) sample-tree)
#+end_src

#+RESULTS:
(0 1 1 0 0 1 0 1 0 1 1 1 0)
** 2.69
*Exercise 2.69:* The following procedure takes as its argument a
list of symbol-frequency pairs (where no symbol appears in more
than one pair) and generates a Huffman encoding tree according to
the Huffman algorithm.
#+begin_src scheme :session haffman
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
#+end_src

#+RESULTS:
: #<unspecified>

`Make-leaf-set' is the procedure given above that transforms the
list of pairs into an ordered set of leaves.  `Successive-merge'
is the procedure you must write, using `make-code-tree' to
successively merge the smallest-weight elements of the set until
there is only one element left, which is the desired Huffman tree.
(This procedure is slightly tricky, but not really complicated.
If you find yourself designing a complex procedure, then you are
almost certainly doing something wrong.  You can take significant
advantage of the fact that we are using an ordered set
representation.)
#+begin_src scheme :session haffman
(define (successive-merge leafs)
  (if (null? (cdr leafs))
      (car leafs)
      (let ((first (car leafs))
            (second (cadr leafs))
            (tail (cddr leafs)))
        (successive-merge (adjoin-set (make-code-tree first second) tail)))))

 (define test-tree (generate-huffman-tree '((A 3) (B 5) (C 6) (D 6))))

 (encode '(A B C D) test-tree)
#+end_src

** 2.70
#+begin_src scheme :session haffman
(define sample-pairs '((A 2) (NA 16) (BOOM 1)
                       (SHA 3) (GET 2) (YIP 9)
                       (JOB 2) (WAH 1)))

(define tree (generate-huffman-tree sample-pairs))

(define sample-message '(GET A JOB SHA NA NA NA NA NA NA
                             NA NA GET A JOB SHA NA NA NA
                             NA NA NA NA NA WAH YIP YIP YIP
                             YIP YIP YIP YIP YIP YIP SHA BOOM))
(encode sample-message tree)
#+end_src
** 2.71
*Exercise 2.71:* Suppose we have a Huffman tree for an alphabet of
n symbols, and that the relative frequencies of the symbols are 1,
2, 4, ..., 2^(n-1).  Sketch the tree for n=5; for n=10.  In such a
tree (for general n) how may bits are required to encode the most
frequent symbol?  the least frequent symbol?
#+begin_comment
Just 1 bit for the most frequent symbol, (n-1) for the least frequent symbol
#+end_comment
** 2.72
#+begin_comment
The order of growth is $\Theta(n \log{n})$
The order of growth of encoding the most frequent symbols is $\Theta(n)$
The order of growth of encoding the least frequent symbols is $\Theta(n^2)$
#+end_comment
* 2.4
