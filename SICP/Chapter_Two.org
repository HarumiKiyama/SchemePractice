# -*- mode: org; coding: utf-8 -*-
#+TITLE: SICP Chapter Two
#+STARTUP: overview

* 2.1
** 2.1
*Exercise 2.1:* Define a better version of `make-rat' that handles
both positive and negative arguments.  `Make-rat' should normalize
the sign so that if the rational number is positive, both the
numerator and denominator are positive, and if the rational number
is negative, only the numerator is negative.

#+begin_src scheme :results raw
(define (make-rat n d)
  (let* ((positive (or (and (<= n 0) (<= d 0))
                       (and (>= n 0) (>= d 0))))
         (g (gcd n d))
         (a (/ (if positive (abs n) (- (abs n))) g))
         (b (/ (abs d) g)))
    (cons a b)))

(make-rat -2 -4)
#+end_src
** 2.2
*Exercise 2.2:* Consider the problem of representing line segments
in a plane.  Each segment is represented as a pair of points: a
starting point and an ending point.  Define a constructor
`make-segment' and selectors `start-segment' and `end-segment'
that define the representation of segments in terms of points.
Furthermore, a point can be represented as a pair of numbers: the
x coordinate and the y coordinate.  Accordingly, specify a
constructor `make-point' and selectors `x-point' and `y-point'
that define this representation.  Finally, using your selectors
and constructors, define a procedure `midpoint-segment' that takes
a line segment as argument and returns its midpoint (the point
whose coordinates are the average of the coordinates of the
endpoints).  To try your procedures, you'll need a way to print
points:

(define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
   
#+begin_src scheme :results output
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

(define (make-segment beg end)
  (cons beg end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))

(define (mid-point-segment seg)
  (let* ((beg (start-segment seg))
         (end (end-segment seg))
         (beg_x (x-point beg))
         (beg_y (y-point beg))
         (end_x (x-point end))
         (end_y (y-point end)))
    (make-point (/ (+ beg_x end_x) 2)
                (/ (+ beg_y end_y) 2))
    )
  )

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(print-point (make-point 1 2))
#+end_src
** 2.3
*Exercise 2.3:* Implement a representation for rectangles in a
plane.  (Hint: You may want to make use of *Note Exercise 2-2::.)
In terms of your constructors and selectors, create procedures
that compute the perimeter and the area of a given rectangle.  Now
implement a different representation for rectangles.  Can you
design your system with suitable abstraction barriers, so that the
same perimeter and area procedures will work using either
representation?
#+begin_src scheme
(define (make-rectangle x y)
  (if (>= x y)
      (cons x y)
      (cons y x)))

(define (get-long r)
  (car x))

(define (get-short r)
  (cdr y))

(define (rec-area r)
  (* (get-long r)
     (get-short r)))

(define (rec-perimeter r)
  (+ (* 2 (get-long r))
     (* 2 (get-short r))))
#+end_src
** 2.4
*Exercise 2.4:* Here is an alternative procedural representation
of pairs.  For this representation, verify that `(car (cons x y))'
yields `x' for any objects `x' and `y'.

(define (cons x y)
    (lambda (m) (m x y)))

(define (car z)
    (z (lambda (p q) p)))

What is the corresponding definition of `cdr'? (Hint: To verify
that this works, make use of the substitution model of section
*Note 1-1-5::.)
#+begin_src scheme
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src
** 2.5
*Exercise 2.5:* Show that we can represent pairs of nonnegative
integers using only numbers and arithmetic operations if we
represent the pair a and b as the integer that is the product 2^a
3^b.  Give the corresponding definitions of the procedures `cons',
`car', and `cdr'.
#+begin_src scheme :results output
(define (cons x y)
  (* (expt 2 x) (expt 3 y)))
(define (car z)
  (if (= (modulo z 2) 0)
      (1+ (car (/ z 2)))
      0))
(define (cdr z)
  (if (= (modulo z 3) 0)
      (1+ (cdr (/ z 3)))
      0))
(display (car (cons 4 12)))
(newline)
(display (cdr (cons 4 12)))

#+end_src

#+RESULTS:
: 4
: 12

** 2.6
*Exercise 2.6:* In case representing pairs as procedures wasn't
mind-boggling enough, consider that, in a language that can
manipulate procedures, we can get by without numbers (at least
insofar as nonnegative integers are concerned) by implementing 0
and the operation of adding 1 as

    (define zero (lambda (f) (lambda (x) x)))
    (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as "Church numerals", after its
inventor, Alonzo Church, the logician who invented the [lambda]
calculus.

Define `one' and `two' directly (not in terms of `zero' and
`add-1').  (Hint: Use substitution to evaluate `(add-1 zero)').
Give a direct definition of the addition procedure `+' (not in
terms of repeated application of `add-1').
#+begin_src scheme
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))))
(define two
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) f) x)))))
#+end_src
* 2.2
